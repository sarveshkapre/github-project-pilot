#!/usr/bin/env node
import { Command } from "commander";
import { readdirSync, readFileSync, mkdirSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { execFileSync } from "node:child_process";
import { z } from "zod";
import { parse as parseYaml } from "yaml";

const BacklogItemSchema = z.object({
  id: z.string().min(1),
  title: z.string().min(1),
  pitch: z.string().min(1),
  owner: z.string().optional(),
  status: z.enum(["backlog", "scaffolded", "mvp", "hardened", "shipped"]).default("backlog"),
  tasks: z.array(z.string().min(1)).default([])
});

const BacklogSchema = z.object({
  project: z.string().min(1),
  generated_by: z.string().optional(),
  items: z.array(BacklogItemSchema).min(1)
});

type Backlog = z.infer<typeof BacklogSchema>;

type IssueDraft = {
  id: string;
  title: string;
  body: string;
  labels: string[];
};

type Templates = {
  issue: string;
  plan: string;
};

type SummaryRow = {
  id: string;
  title: string;
  labels: string[];
};

const program = new Command();

program
  .name("gh-project-pilot")
  .description("Local-first backlog to plans and issue drafts.")
  .version("0.1.0");

program
  .command("simulate")
  .description("Generate a local plan and issue drafts from a backlog YAML file.")
  .requiredOption("-i, --input <file>", "backlog YAML file")
  .option("-o, --out <dir>", "output directory", "./out")
  .option("--issue-template <file>", "issue template file path")
  .option("--plan-template <file>", "plan template file path")
  .option("--report <dir>", "summary report directory (relative to output)", "report")
  .option("--html-report", "generate HTML report in report directory", true)
  .option("--html-theme <name>", "HTML report theme (paper|mono)", "paper")
  .option("--allow-missing-placeholders", "allow templates to omit required placeholders", false)
  .option("--dry-run", "print summary only", false)
  .action((options) => {
    const backlog = loadBacklog(options.input);
    const templates = loadTemplates(options.issueTemplate, options.planTemplate);
    if (!options.allowMissingPlaceholders) {
      validateTemplates(templates);
    }
    const issues = buildIssueDrafts(backlog, templates);
    const plan = buildPlan(backlog, templates);

    if (options.dryRun) {
      printSummary(backlog, issues);
      return;
    }

    const theme = normalizeTheme(options.htmlTheme);
    writeOutputs(options.out, plan, issues, options.report, options.htmlReport, theme);
    printSummary(backlog, issues, options.out);
  });

program
  .command("publish")
  .description("Create GitHub Issues from a summary CSV and issue drafts via gh CLI.")
  .requiredOption("--repo <owner/repo>", "target GitHub repository")
  .requiredOption("--issues-dir <dir>", "directory containing issue draft markdown files")
  .requiredOption("--report-csv <file>", "summary CSV generated by simulate")
  .option("--limit <n>", "publish at most N issues", parseInteger)
  .option("--delay-ms <n>", "delay between publishes in ms", parseInteger, 0)
  .option("--dry-run", "print intended gh commands without publishing", false)
  .action(async (options) => {
    const rows = loadSummaryCsv(options.reportCsv);
    const issueFiles = listIssueFiles(options.issuesDir);
    const payloads = buildPublishPayloads(rows, issueFiles);
    const selected = applyLimit(payloads, options.limit);

    if (options.dryRun) {
      selected.forEach((payload) => {
        console.log(
          `[dry-run] gh issue create --repo ${options.repo} --title ${payload.title} --label ${payload.labels.join(",")}`
        );
      });
      return;
    }

    for (const payload of selected) {
      createGitHubIssue(options.repo, payload);
      if (options.delayMs > 0) {
        await sleep(options.delayMs);
      }
    }
  });

program
  .command("project-drafts")
  .description("Create GitHub Project draft items from a summary CSV via gh CLI.")
  .requiredOption("--owner <owner>", "project owner (user or org)")
  .requiredOption("--project-number <n>", "project number", parseInteger)
  .requiredOption("--issues-dir <dir>", "directory containing issue draft markdown files")
  .requiredOption("--report-csv <file>", "summary CSV generated by simulate")
  .option("--limit <n>", "create at most N draft items", parseInteger)
  .option("--delay-ms <n>", "delay between creates in ms", parseInteger, 0)
  .option("--dry-run", "print intended gh commands without publishing", false)
  .action(async (options) => {
    const rows = loadSummaryCsv(options.reportCsv);
    const issueFiles = listIssueFiles(options.issuesDir);
    const payloads = buildPublishPayloads(rows, issueFiles);
    const selected = applyLimit(payloads, options.limit);

    if (options.dryRun) {
      selected.forEach((payload) => {
        console.log(
          `[dry-run] gh project item-create ${options.projectNumber} --owner ${options.owner} --title ${payload.title}`
        );
      });
      return;
    }

    for (const payload of selected) {
      createProjectDraft(options.owner, options.projectNumber, payload);
      if (options.delayMs > 0) {
        await sleep(options.delayMs);
      }
    }
  });

program.parse(process.argv);

function loadBacklog(filePath: string): Backlog {
  const raw = readFileSync(filePath, "utf8");
  const parsed = parseYaml(raw);
  return BacklogSchema.parse(parsed);
}

function buildIssueDrafts(backlog: Backlog, templates: Templates): IssueDraft[] {
  return backlog.items.map((item) => {
    const label = `status:${item.status}`;
    const tasks = item.tasks.length ? item.tasks.map((t) => `- ${t}`).join("\n") : "- Define tasks";
    const body = applyTemplate(templates.issue, {
      project: backlog.project,
      id: item.id,
      title: item.title,
      pitch: item.pitch,
      owner: item.owner ?? "unassigned",
      status: item.status,
      tasks,
      labels: label,
      acceptance: [
        "- Plan exists in /plans",
        "- Docs updated (PLAN/PROJECT/CHANGELOG)",
        "- check passes"
      ].join("\n")
    });

    return {
      id: item.id,
      title: item.title,
      body,
      labels: [label]
    };
  });
}

function buildPlan(backlog: Backlog, templates: Templates): string {
  const items = backlog.items
    .map((item, index) => {
      const tasks = item.tasks.length ? item.tasks.map((t) => `- ${t}`).join("\n") : "- Define tasks";
      return [
        `## ${index + 1}. ${item.title}`,
        `ID: ${item.id}`,
        item.pitch,
        `Status: ${item.status}`,
        "Tasks:",
        tasks,
        "",
        "Risks:",
        "- Scope creep",
        "- Missing tests",
        "- Unsafe defaults"
      ].join("\n");
    })
    .join("\n\n");

  return applyTemplate(templates.plan, {
    project: backlog.project,
    generated_at: new Date().toISOString(),
    items
  });
}

function writeOutputs(
  outDir: string,
  plan: string,
  issues: IssueDraft[],
  reportDir: string,
  htmlReport: boolean,
  htmlTheme: string
): void {
  mkdirSync(outDir, { recursive: true });
  const planPath = join(outDir, "plan.md");
  writeFileSync(planPath, plan);

  const issuesDir = join(outDir, "issues");
  mkdirSync(issuesDir, { recursive: true });

  issues.forEach((issue, index) => {
    const safeTitle = issue.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
    const filePath = join(
      issuesDir,
      `${String(index + 1).padStart(2, "0")}-${issue.id}-${safeTitle}.md`
    );
    const content = [
      `# ${issue.title}`,
      "",
      issue.body,
      "",
      `Labels: ${issue.labels.join(", ")}`
    ].join("\n");
    writeFileSync(filePath, content);
  });

  const summary = writeSummary(outDir, reportDir, issues);
  if (htmlReport) {
    writeHtmlReport(outDir, reportDir, plan, issues, summary, htmlTheme);
  }
}

function printSummary(backlog: Backlog, issues: IssueDraft[], outDir?: string): void {
  console.log(`Backlog project: ${backlog.project}`);
  console.log(`Items: ${backlog.items.length}`);
  console.log(`Issues drafted: ${issues.length}`);
  if (outDir) {
    console.log(`Outputs: ${outDir}`);
  }
}

function loadTemplates(issueTemplatePath?: string, planTemplatePath?: string): Templates {
  const defaultIssue = [
    "Project: {{project}}",
    "ID: {{id}}",
    "Title: {{title}}",
    "Owner: {{owner}}",
    "Status: {{status}}",
    "Labels: {{labels}}",
    "",
    "{{pitch}}",
    "",
    "Tasks:",
    "{{tasks}}",
    "",
    "Acceptance criteria:",
    "{{acceptance}}"
  ].join("\n");
  const defaultPlan = [
    "# {{project}} - Execution Plan",
    "",
    "Generated: {{generated_at}}",
    "",
    "{{items}}",
    ""
  ].join("\n");

  return {
    issue: issueTemplatePath ? readFileSync(issueTemplatePath, "utf8") : defaultIssue,
    plan: planTemplatePath ? readFileSync(planTemplatePath, "utf8") : defaultPlan
  };
}

function applyTemplate(template: string, data: Record<string, string>): string {
  return template.replace(/\{\{(\w+)\}\}/g, (_match, key) => data[key] ?? "");
}

function writeSummary(outDir: string, reportDir: string, issues: IssueDraft[]): SummaryRow[] {
  const reportPath = join(outDir, reportDir);
  mkdirSync(reportPath, { recursive: true });

  const jsonPath = join(reportPath, "summary.json");
  const csvPath = join(reportPath, "summary.csv");

  const json = issues.map((issue) => ({
    id: issue.id,
    title: issue.title,
    labels: issue.labels.join(";")
  }));
  const summaryRows = issues.map((issue) => ({
    id: issue.id,
    title: issue.title,
    labels: issue.labels
  }));

  const csvHeader = "id,title,labels";
  const csvRows = issues.map((issue) =>
    [issue.id, escapeCsv(issue.title), escapeCsv(issue.labels.join(";"))].join(",")
  );

  writeFileSync(jsonPath, JSON.stringify(json, null, 2));
  writeFileSync(csvPath, [csvHeader, ...csvRows].join("\n"));

  return summaryRows;
}

function escapeCsv(value: string): string {
  if (value.includes(",") || value.includes("\"") || value.includes("\n")) {
    return `"${value.replace(/"/g, "\"\"")}"`;
  }
  return value;
}

function writeHtmlReport(
  outDir: string,
  reportDir: string,
  plan: string,
  issues: IssueDraft[],
  summary: SummaryRow[],
  theme: string
): void {
  const reportPath = join(outDir, reportDir);
  const htmlPath = join(reportPath, "index.html");
  const issueList = summary
    .map(
      (row) =>
        `<tr><td>${escapeHtml(row.id)}</td><td>${escapeHtml(row.title)}</td><td>${escapeHtml(
          row.labels.join(", ")
        )}</td></tr>`
    )
    .join("");

  const issueSections = issues
    .map(
      (issue) => `
      <section class="issue">
        <h3>${escapeHtml(issue.title)}</h3>
        <pre>${escapeHtml(issue.body)}</pre>
      </section>`
    )
    .join("");

  const html = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GitHub Project Pilot Report</title>
    <style>
      ${theme === "mono" ? monoThemeCss() : paperThemeCss()}
    </style>
  </head>
  <body>
    <h1>GitHub Project Pilot Report</h1>
    <h2>Plan</h2>
    <pre>${escapeHtml(plan)}</pre>
    <h2>Issue Summary</h2>
    <table>
      <thead><tr><th>ID</th><th>Title</th><th>Labels</th></tr></thead>
      <tbody>${issueList}</tbody>
    </table>
    <h2>Issue Drafts</h2>
    ${issueSections}
  </body>
</html>`;

  writeFileSync(htmlPath, html);
}

function escapeHtml(value: string): string {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function normalizeTheme(theme: string): string {
  const normalized = theme.toLowerCase();
  if (normalized !== "paper" && normalized !== "mono") {
    console.warn(`Unknown theme "${theme}", falling back to "paper".`);
    return "paper";
  }
  return normalized;
}

function paperThemeCss(): string {
  return `
    :root { color-scheme: light; }
    body { font-family: "SF Pro Text", "Iowan Old Style", serif; margin: 2rem; background: #f6f1e7; color: #1e1b16; }
    h1, h2, h3 { margin-top: 1.5rem; font-family: "Avenir Next", "Helvetica Neue", sans-serif; }
    pre { background: #1d1a16; color: #f0e6d8; padding: 1rem; overflow-x: auto; border-radius: 8px; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; background: #fffaf0; }
    th, td { border: 1px solid #d1c6b3; padding: 0.5rem; text-align: left; }
    .issue { border-top: 1px solid #c8bda8; padding-top: 1rem; }
  `;
}

function monoThemeCss(): string {
  return `
    :root { color-scheme: dark; }
    body { font-family: "IBM Plex Mono", "SF Mono", monospace; margin: 2rem; background: #0d0f12; color: #e6e6e6; }
    h1, h2, h3 { margin-top: 1.5rem; text-transform: uppercase; letter-spacing: 0.04em; }
    pre { background: #151a20; color: #d6f0ff; padding: 1rem; overflow-x: auto; border-radius: 6px; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; background: #101318; }
    th, td { border: 1px solid #2a313b; padding: 0.5rem; text-align: left; }
    .issue { border-top: 1px solid #2a313b; padding-top: 1rem; }
  `;
}

function loadSummaryCsv(filePath: string): SummaryRow[] {
  const raw = readFileSync(filePath, "utf8").trim();
  if (!raw) {
    return [];
  }
  const lines = parseCsv(raw);
  const header = lines.shift();
  if (!header || header.join(",") !== "id,title,labels") {
    throw new Error("summary CSV must have header: id,title,labels");
  }
  return lines.map(([id, title, labels]) => ({
    id,
    title,
    labels: labels ? labels.split(";").filter(Boolean) : []
  }));
}

function parseCsv(input: string): string[][] {
  const rows: string[][] = [];
  let current: string[] = [];
  let cell = "";
  let inQuotes = false;

  for (let i = 0; i < input.length; i += 1) {
    const char = input[i];
    const next = input[i + 1];
    if (char === "\"") {
      if (inQuotes && next === "\"") {
        cell += "\"";
        i += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }
    if (char === "," && !inQuotes) {
      current.push(cell);
      cell = "";
      continue;
    }
    if ((char === "\n" || char === "\r") && !inQuotes) {
      if (char === "\r" && next === "\n") {
        i += 1;
      }
      current.push(cell);
      rows.push(current);
      current = [];
      cell = "";
      continue;
    }
    cell += char;
  }
  current.push(cell);
  rows.push(current);
  return rows;
}

function listIssueFiles(dir: string): string[] {
  return readdirSync(dir)
    .filter((name) => name.endsWith(".md"))
    .map((name) => join(dir, name));
}

function buildPublishPayloads(rows: SummaryRow[], issueFiles: string[]): IssueDraft[] {
  return rows.map((row) => {
    const match = issueFiles.find((file) => file.includes(`-${row.id}-`));
    if (!match) {
      throw new Error(`Missing issue draft file for id ${row.id}`);
    }
    const content = readFileSync(match, "utf8");
    const [titleLine, ...rest] = content.split("\n");
    const body = titleLine.startsWith("# ") ? rest.join("\n").trim() : content.trim();
    return {
      id: row.id,
      title: row.title,
      body,
      labels: row.labels
    };
  });
}

function createGitHubIssue(repo: string, issue: IssueDraft): void {
  const args = [
    "issue",
    "create",
    "--repo",
    repo,
    "--title",
    issue.title,
    "--body",
    issue.body
  ];

  issue.labels.forEach((label) => {
    args.push("--label", label);
  });

  execFileSync("gh", args, { stdio: "inherit" });
}

function createProjectDraft(owner: string, projectNumber: number, issue: IssueDraft): void {
  const args = [
    "project",
    "item-create",
    String(projectNumber),
    "--owner",
    owner,
    "--title",
    issue.title,
    "--body",
    issue.body
  ];
  execFileSync("gh", args, { stdio: "inherit" });
}

function validateTemplates(templates: Templates): void {
  assertTemplateHasPlaceholders(templates.issue, "issue", [
    "project",
    "id",
    "title",
    "pitch",
    "owner",
    "status",
    "tasks",
    "labels",
    "acceptance"
  ]);
  assertTemplateHasPlaceholders(templates.plan, "plan", ["project", "generated_at", "items"]);
}

function assertTemplateHasPlaceholders(template: string, name: string, required: string[]): void {
  const missing = required.filter((key) => !template.includes(`{{${key}}}`));
  if (missing.length > 0) {
    throw new Error(`Template ${name} missing placeholders: ${missing.join(", ")}`);
  }
}

function applyLimit<T>(items: T[], limit?: number): T[] {
  if (!limit || limit <= 0) {
    return items;
  }
  return items.slice(0, limit);
}

function parseInteger(value: string): number {
  const parsed = Number.parseInt(value, 10);
  if (Number.isNaN(parsed)) {
    throw new Error(`Invalid number: ${value}`);
  }
  return parsed;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
